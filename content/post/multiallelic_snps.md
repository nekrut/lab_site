---
title: "Parsing multiallelic sites"
date: 2019-08-26
tags: [snp, VCF, variant calling]
author: Anton
show_summary: true 
---

{{< background "warning" >}}
In diploid systems (e.g., human) multiallelic sites are often ignored. However, in bacterial and viral mixtures multiallelic sites are real and parsing them correctly is critical for understanding the full magnitude of sequence variation. 
{{< /background >}}

## The goal

To compare various ways of calling variants in haploid systems I needed to convert VCF files into TAB-delimited format, while parsing out multiallelic sites. 

## The data

In this experiment we called SNPs from Illumina data obtained by sequencing of HIV's *pol* gene amplicons. The data was generated by [Jair et al. 2019](http://dx.doi.org/10.1371/journal.pone.0214820). For the sake of brevity the following discussion uses a single dataset from this study with accession [SRR8525899](https://www.ncbi.nlm.nih.gov/sra/?term=SRR8525899).

Variants were called using `freebayes` (version <kbd>1.3.1</kbd> build <kbd>py37he0122c3_0</kbd> from [bioconda](https://bioconda.github.io/recipes/freebayes/README.html)) and `Mutect2` (GATK version <kbd>4.1.3.0</kbd> build <kbd>0</kbd> from [bioconda](https://anaconda.org/bioconda/gatk4)). The following commands were used to call variants (in both cases `hxb2` refers to the reference sequence for the [HIV genome (K03455.1)](https://www.ncbi.nlm.nih.gov/nuccore/K03455.1/):

#### FreeBayes:
`freebayes -f hxb2.fa --min-coverage 100 --limit-coverage 1000 --haplotype-length 0 -q 20 -m 20 --min-alternate-count 1 --min-alternate-fraction 0 --pooled-continuous <BAM dataset> > <VCF file>`

#### Mutect2:
`gatk Mutect2 -I <BAM dataset> -mbq 20 -R hxb2.fa --mitochondria-mode True -O <VCF file>`

## The site

Resulting VCFs contained a number of multiallelic sites. Here is an example of a complex site identified by `freebayes`:

```
K03455.1        2911    .       ATG     CCA,GCA,ACA,ACG,ATA     10482.7 .       AB=0,0,0,0,0;ABP=0,0,0,0,0;AC=0,0,2,0,0;AF=0,0,1,0,0;AN=2;AO=1,2,310,1,2;CIGAR=3X,3X,1M2X,1M1X1M,2M1X;DP=316;DPB=316;DPRA=0,0,0,0,0;EPP=5.18177,3.0103,5.8122,5.18177,3.0103;EPPR=0;GTI=0;LEN=3,3,2,1,1;MEANALT=5,5,5,5,5;MQM=60,60,59.9032,60,60;MQMR=0;NS=1;NUMALT=5;ODDS=413.347;PAIRED=1,1,1,1,1;PAIREDR=0;PAO=0,0,0,0,0;PQA=0,0,0,0,0;PQR=0;PRO=0;QA=27,76,11724,39,72;QR=0;RO=0;RPL=1,2,165,1,2;RPP=5.18177,7.35324,5.8122,5.18177,7.35324;RPPR=0;RPR=0,0,145,0,0;RUN=1,1,1,1,1;SAF=0,1,178,1,1;SAP=5.18177,3.0103,17.8324,5.18177,3.0103;SAR=1,1,132,0,1;SRF=0;SRP=0;SRR=0;TYPE=complex,complex,mnp,snp,snp      GT:DP:AD:RO:QR:AO:QA:GL 3/3:316:0,1,2,310,1,2:0:0:1,2,310,1,2:27,76,11724,39,72:-1054.34,-1052.22,-1051.91,-1048.11,-1045.98,-1047.51,-93.3193,-91.2078,-87.0746,0,-1051.14,-1049.01,-1044.9,-90.1068,-1050.84,-1048.47,-1046.34,-1042.24,-87.4429,-1045.26,-1047.87
```

There are five alternative alleles. This is why tags describing these alleles contain lists of values instead of a single value. For example, `AO` (Count of full observations of this alternate haplotype) is `1,2,310,1,2` and so on. If you look carefully at this site you will see that it is actually *almost* fixed for `ACA` with other alleles having very low counts and no reference allele is present. 

For meaningful processing of these data (at least in my mind) it is necessary to split multiple alleles into individual events and then deal with them separately. In fact, in the study I am trying to complete I am comparing various variant callers applied to a variety of non-diploid systems randing from viruses to human mitichondria. So my goal is to convert VCF datasets into tab-delimited files that I can import into `Pandas` and analyze happily. So how can only split multiallelic VCF entries without writing another parser. 

## Splitting multiallelic VCF entries

### VCFlib

[`VCFlib`](https://github.com/vcflib/vcflib) is a fast C-based collection of utilities for processing of VCF data (here I am using `vcflib` version <kbd>1.0.0_rc2</kbd> build <kbd>he0122c3_2</kbd> from [bioconda](https://anaconda.org/bioconda/vcflib)). For our purpose it has a specifically designed utility called [`vcfbreakmulti`](https://github.com/vcflib/vcflib#vcfbreakmulti). Let's try it on out site. Here is what we get:

```
K03455.1        2911    .       ATG     CCA     10482.7 .       AB=0;ABP=0;AC=0;AF=0;AN=2;AO=1;CIGAR=3X;DP=316;DPB=316;DPRA=0;EPP=5.18177;EPPR=0;GTI=0;LEN=3;MEANALT=5;MQM=60;MQMR=0;NS=1;NUMALT=5;ODDS=413.347;PAIRED=1;PAIREDR=0;PAO=0;PQA=0;PQR=0;PRO=0;QA=27;QR=0;RO=0;RPL=1;RPP=5.18177;RPPR=0;RPR=0;RUN=1;SAF=0;SAP=5.18177;SAR=1;SRF=0;SRP=0;SRR=0;TYPE=complex  GT:DP:AD:RO:QR:AO:QA:GL ./.:316:0,1,2,310,1,2:0:0:1:27:-1054.34,-1052.22,-1051.91
K03455.1        2911    .       ATG     GCA     10482.7 .       AB=0;ABP=0;AC=0;AF=0;AN=2;AO=2;CIGAR=3X;DP=316;DPB=316;DPRA=0;EPP=3.0103;EPPR=0;GTI=0;LEN=3;MEANALT=5;MQM=60;MQMR=0;NS=1;NUMALT=5;ODDS=413.347;PAIRED=1;PAIREDR=0;PAO=0;PQA=0;PQR=0;PRO=0;QA=76;QR=0;RO=0;RPL=2;RPP=7.35324;RPPR=0;RPR=0;RUN=1;SAF=1;SAP=3.0103;SAR=1;SRF=0;SRP=0;SRR=0;TYPE=complex    GT:DP:AD:RO:QR:AO:QA:GL ./.:316:0,1,2,310,1,2:0:0:2:76:-1054.34,-1048.11,-1047.51
K03455.1        2911    .       ATG     ACA     10482.7 .       AB=0;ABP=0;AC=2;AF=1;AN=2;AO=310;CIGAR=1M2X;DP=316;DPB=316;DPRA=0;EPP=5.8122;EPPR=0;GTI=0;LEN=2;MEANALT=5;MQM=59.9032;MQMR=0;NS=1;NUMALT=5;ODDS=413.347;PAIRED=1;PAIREDR=0;PAO=0;PQA=0;PQR=0;PRO=0;QA=11724;QR=0;RO=0;RPL=165;RPP=5.8122;RPPR=0;RPR=145;RUN=1;SAF=178;SAP=17.8324;SAR=132;SRF=0;SRP=0;SRR=0;TYPE=mnp    GT:DP:AD:RO:QR:AO:QA:GL 1/1:316:0,1,2,310,1,2:0:0:310:11724:-1054.34,-93.3193,0
K03455.1        2911    .       ATG     ACG     10482.7 .       AB=0;ABP=0;AC=0;AF=0;AN=2;AO=1;CIGAR=1M1X1M;DP=316;DPB=316;DPRA=0;EPP=5.18177;EPPR=0;GTI=0;LEN=1;MEANALT=5;MQM=60;MQMR=0;NS=1;NUMALT=5;ODDS=413.347;PAIRED=1;PAIREDR=0;PAO=0;PQA=0;PQR=0;PRO=0;QA=39;QR=0;RO=0;RPL=1;RPP=5.18177;RPPR=0;RPR=0;RUN=1;SAF=1;SAP=5.18177;SAR=0;SRF=0;SRP=0;SRR=0;TYPE=snp  GT:DP:AD:RO:QR:AO:QA:GL ./.:316:0,1,2,310,1,2:0:0:1:39:-1054.34,-1051.14,-1050.84
K03455.1        2911    .       ATG     ATA     10482.7 .       AB=0;ABP=0;AC=0;AF=0;AN=2;AO=2;CIGAR=2M1X;DP=316;DPB=316;DPRA=0;EPP=3.0103;EPPR=0;GTI=0;LEN=1;MEANALT=5;MQM=60;MQMR=0;NS=1;NUMALT=5;ODDS=413.347;PAIRED=1;PAIREDR=0;PAO=0;PQA=0;PQR=0;PRO=0;QA=72;QR=0;RO=0;RPL=2;RPP=7.35324;RPPR=0;RPR=0;RUN=1;SAF=1;SAP=3.0103;SAR=1;SRF=0;SRP=0;SRR=0;TYPE=snp      GT:DP:AD:RO:QR:AO:QA:GL ./.:316:0,1,2,310,1,2:0:0:2:72:-1054.34,-1048.47,-1047.87
```

looking at VCFs is truly a unique form of a cruel punishment, so let's take a closer look at `INFO`- and `FORMAT`- level fields. This can be done through a combination of `vcfbreakmulti`, `vcf2tsv` (another utility from `vcflib` package that converts VCF into tab-delimited data), [`datamash`](https://www.gnu.org/software/datamash/manual/datamash.html#Transpose) `traspose` function:

```
cat <VCF file> | vcfbreakmulti | vcf2tsv | datamash traspose
```

{{< background "success" >}}
Adding <tt>-g</tt> flag to <tt>vcf2tsv</tt> will parse genotype fields as well.
{{< /background >}}



|<h4>Field</h4>|<h4>A1</h4>|<h4>A2</h4>|<h4>A3</h4>|<h4>A4</h4>|<h4>A5</h4>|
|----|----|----|----|----|----|
|POS|2911|2911|2911|2911|2911|
|ID|.|.|.|.|.|
|REF|ATG|ATG|ATG|ATG|ATG|
|ALT|CCA|GCA|ACA|ACG|ATA|
|QUAL|10482.7|10482.7|10482.7|10482.7|10482.7|
|FILTER|.|.|.|.|.|
|AB|0|0|0|0|0|
|ABP|0|0|0|0|0|
|AC|0|0|2|0|0|
|AF|0|0|1|0|0|
|AN|2|2|2|2|2|
|AO|1|2|310|1|2|
|CIGAR|3X|3X|1M2X|1M1X1M|2M1X|
|DP|316|316|316|316|316|
|DPB|316|316|316|316|316|
|DPRA|0|0|0|0|0|
|END|.|.|.|.|.|
|EPP|5.18177|3.0103|5.8122|5.18177|3.0103|
|EPPR|0|0|0|0|0|
|GTI|0|0|0|0|0|
|LEN|3|3|2|1|1|
|MEANALT|5|5|5|5|5|
|MIN_DP|.|.|.|.|.|
|MQM|60|60|59.9032|60|60|
|MQMR|0|0|0|0|0|
|NS|1|1|1|1|1|
|NUMALT|5|5|5|5|5|
|ODDS|413.347|413.347|413.347|413.347|413.347|
|PAIRED|1|1|1|1|1|
|PAIREDR|0|0|0|0|0|
|PAO|0|0|0|0|0|
|PQA|0|0|0|0|0|
|PQR|0|0|0|0|0|
|PRO|0|0|0|0|0|
|QA|27|76|11724|39|72|
|QR|0|0|0|0|0|
|RO|0|0|0|0|0|
|RPL|1|2|165|1|2|
|RPP|5.18177|7.35324|5.8122|5.18177|7.35324|
|RPPR|0|0|0|0|0|
|RPR|0|0|145|0|0|
|RUN|1|1|1|1|1|
|SAF|0|1|178|1|1|
|SAP|5.18177|3.0103|17.8324|5.18177|3.0103|
|SAR|1|1|132|0|1|
|SRF|0|0|0|0|0|
|SRP|0|0|0|0|0|
|SRR|0|0|0|0|0|
|TYPE|complex|complex|mnp|snp|snp|

### GATK

GATK's equivalent of `vcflib`'s  `vcfbreakmulti | vcf2tab` combination is [`VariantsToTable`](https://software.broadinstitute.org/gatk/documentation/tooldocs/current/org_broadinstitute_hellbender_tools_walkers_variantutils_VariantsToTable.php) (also see [LeftAlignAndTrimVariants](https://software.broadinstitute.org/gatk/documentation/tooldocs/current/org_broadinstitute_hellbender_tools_walkers_variantutils_LeftAlignAndTrimVariants.php). Here I used GATK version <kbd>4.1.3.0</kbd> build <kbd>0</kbd> from [bioconda](https://anaconda.org/bioconda/gatk4).

One functional difference with `vcfbreakmulti` discussed above is the fact that  `VariantsToTable` requires the user to explicitly define which tags to parse. For example, to parse a VCF file generated with `freebayes` the command line will look like this:

```
gatk VariantsToTable -SMA -V <BAM input> -O <TAB-delimited output> -F POS -F REF -F ALT -F NS -F DP -F DPB -F AC -F AN -F AF -F RO -F AO -F PRO -F PAO -F QR -F QA -F PQR -F PQA -F SRF -F SRR -F SAF -F SAR -F SRP -F SAP -F AB -F ABP -F RUN -F RPP -F RPPR -F RPL -F RPR -F EPP -F EPPR -F DPRA -F ODDS -F GTI -F TYPE -F CIGAR -F NUMALT -F MEANALT -F LEN -F MQM -F MQMR -F PAIRED -F PAIREDR -F MIN_DP -F END -GF GT -GF GQ -GF GL -GF DP -GF AD -GF RO -GF QR -GF AO -GF QA -GF MIN_DP
```

{{< background "success" >}}
Note the <tt>-SMA</tt> flag, which tells the tool to split multiallelic sites. The <tt>-GF</tt> flag is equivalent to <tt>-g</tt> flag of <tt>vcf2tab</tt>.
{{< /background >}}

In the case of our site running the above command and processing its output with:

```
cat <TAB-delimited output of VariantsToTable | datamash transpose 
```

|<h4>Field</h4>|<h4>A1</h4>|<h4>A2</h4>|<h4>A3</h4>|<h4>A4</h4>|<h4>A5</h4>|
|----|----|----|----|----|----|
|POS|2911|2911|2911|2911|2911|
|REF|ATG|ATG|ATG|ATG|ATG|
|ALT|CCA|GCA|ACA|ACG|ATA|
|NS|1|1|1|1|1|
|DP|316|316|316|316|316|
|DPB|316|316|316|316|316|
|AC|0|0|2|0|0|
|AN|2|2|2|2|2|
|AF|0|0|1|0|0|
|RO|0|0|0|0|0|
|AO|1|2|310|1|2|
|PRO|0|0|0|0|0|
|PAO|0|0|0|0|0|
|QR|0|0|0|0|0|
|QA|27|76|11724|39|72|
|PQR|0|0|0|0|0|
|PQA|0|0|0|0|0|
|SRF|0|0|0|0|0|
|SRR|0|0|0|0|0|
|SAF|0|1|178|1|1|
|SAR|1|1|132|0|1|
|SRP|0|0|0|0|0|
|SAP|5.18177|3.0103|17.8324|5.18177|3.0103|
|AB|0|0|0|0|0|
|ABP|0|0|0|0|0|
|RUN|1|1|1|1|1|
|RPP|5.18177|7.35324|5.8122|5.18177|7.35324|
|RPPR|0|0|0|0|0|
|RPL|1|2|165|1|2|
|RPR|0|0|145|0|0|
|EPP|5.18177|3.0103|5.8122|5.18177|3.0103|
|EPPR|0|0|0|0|0|
|DPRA|0|0|0|0|0|
|ODDS|413.347|413.347|413.347|413.347|413.347|
|GTI|0|0|0|0|0|
|TYPE|MNP|MNP|MNP|MNP|MNP|
|CIGAR|3X|3X|1M2X|1M1X1M|2M1X|
|NUMALT|5|5|5|5|5|
|MEANALT|5|5|5|5|5|
|LEN|3|3|2|1|1|
|MQM|60|60|59.9032|60|60|
|MQMR|0|0|0|0|0|
|PAIRED|1|1|1|1|1|
|PAIREDR|0|0|0|0|0|
|MIN_DP|NA|NA|NA|NA|NA|
|END|NA|NA|NA|NA|NA|
|SRR8525899.GT|ACA/ACA|ACA/ACA|ACA/ACA|ACA/ACA|ACA/ACA|
|SRR8525899.GQ|NA|NA|NA|NA|NA|
|SRR8525899.GL|NA|NA|NA|NA|NA|
|SRR8525899.DP|316|316|316|316|316|
|SRR8525899.AD|0,1,2,310,1,2|0,1,2,310,1,2|0,1,2,310,1,2|0,1,2,310,1,2|0,1,2,310,1,2|
|SRR8525899.RO|0|0|0|0|0|
|SRR8525899.QR|0|0|0|0|0|
|SRR8525899.AO|1,2,310,1,2|1,2,310,1,2|1,2,310,1,2|1,2,310,1,2|1,2,310,1,2|
|SRR8525899.QA|27,76,11724,39,72|27,76,11724,39,72|27,76,11724,39,72|27,76,11724,39,72|27,76,11724,39,72|
|SRR8525899.MIN_DP|NA|NA|NA|NA|NA|

### bcftools

[`bcftools`](https://github.com/samtools/bcftools) can be used to achieve the same result with two utilities: `norm` and `query`. Here I used `bcftools` version <kbd>1.9</kbd>, build <kbd>h444d1bb_5</kbd> installed using [bioconda](https://anaconda.org/bioconda/vcftools). In case of `query` one needs to explicitly write the format of the output including names of fields, delimiters, and end-of-the-line characters:

```
bcftools norm -m - SRR8525899_f.vcf | bcftools query -f '%CHROM\t%POS\t%REF\t%DP\t%RO\t%AO\t%ALT\t%SAF\t%SAR\t%SRF\t%SRR\n'
```

The output will look like this (this is, again, a transposed version for clarity):


|<h4>Field</h4>|<h4>A1</h4>|<h4>A2</h4>|<h4>A3</h4>|<h4>A4</h4>|<h4>A5</h4>|
|----|----|----|----|----|----|
|POS|2911|2911|2911|2911|2911|
|REF|ATG|ATG|ATG|ATG|ATG|
|ALT|316|316|316|316|316|
|RO|0|0|0|0|0|
|AO|1|2|310|1|2|
|ALT|CCA|GCA|ACA|ACG|ATA|
|SAF|0|1|178|1|1|
|SAR|1|1|132|0|1|
|SRF|0|0|0|0|0|
|SRR|0|0|0|0|0|

## Conclusions

### Usability

The three approaches, `vcflib`, `gatk`, and `bcftools` all achieve the same result (obviously). 

 - `vcftools` is perhaps the easiest way to do this because it does not require *a priori* knowledge of all the fields in the VCF file - it just parses them all. However, in some instances `vcfbreakmulti` was hanging on certain files that contain variants with large number of alternative alleles (low complexity regions). This is intermittent: sometimes it hangs and sometimes it does not (I wasn't able to pinpoint the exact cause). It is really straightforward to pipe from one `vcflib` utility to another. 
 - `gatk`'s `VariantsToTable` is one command that does both things - splits multiallelic sites and converts to tab-delimited format. The challenge is forming the correct command line with all VCF flags to extract. Piping is a little weird with `gatk` as you need to explicitly state `-O /dev/stdout`.
 - `bcftools` requites the use of two utilities and also forces the user to construct the list of fields and formatting options. Just like in the case of `vcflib` piping is easy.

### Project health

Here is a simple GitHub-based statistics (as of August 27, 2018):

| Tool     | Last commit | Total commits | # Issues (open/closed) | # PRs (open/closed) | # Releases |
|----------|-------------|---------------|------------------------|---------------------|------------|
|`vcflib`  | Aug 7 2019 | 724           | 118/63 | 8/63 | 4 |
|`gatk`    | Aug 27 2019 | 3931 | 961/2556 | 67/2540 | 38 | 
|`bcftools`| Aug 20 2019 | 2064 | 147/762 | 3/162 | 28 |


Based on this `bcftools` is probably the best option as it is well maintained and is not written in java ;). 





